{"version":3,"file":"main.9c8aeff8f2ed4db39f5e.bundle.js","sources":["webpack:///../core/src/mixins/delegate-focus-mixin.js","webpack:///../core/src/components/button.js","webpack:///../core/src/components/checkbox.js","webpack:///../core/src/components/progress.js","webpack:///../core/src/styles/range-base-css.js","webpack:///../core/src/components/range.js","webpack:///../core/src/components/switch.js"],"sourcesContent":["const $$tabindex = Symbol('tabindex');\nconst $$oldTabindex = Symbol('oldTabindex');\nconst $$newTabindex = Symbol('newTabindex');\n\nexport const DelegateFocusMixin = superClass =>\n  class extends superClass {\n    static get properties() {\n      return {\n        tabIndex: {\n          converter: {\n            fromAttribute: Number,\n            toAttribute: value => (value == null ? null : value.toString())\n          },\n          noAccessor: true,\n          reflect: true\n        },\n\n        /**\n         * If true, the user cannot interact with this element.\n         */\n        disabled: {\n          type: Boolean,\n          reflect: true\n        }\n      };\n    }\n\n    constructor() {\n      super();\n      if (!this.hasAttribute('tabindex')) {\n        this.tabIndex = 0;\n      }\n    }\n\n    get tabIndex() {\n      return this[$$tabindex];\n    }\n\n    set tabIndex(value) {\n      const oldValue = this[$$tabindex];\n      this[$$tabindex] = value;\n      this.requestUpdate('tabIndex', oldValue);\n    }\n\n    firstUpdated() {\n      this.addEventListener('focusin', e => {\n        if (e.composedPath()[0] === this) {\n          this._focus();\n        }\n      });\n\n      this.addEventListener('keydown', e => {\n        if (!e.defaultPrevented && e.shiftKey && e.keyCode === 9) {\n          // Flag is checked in _focus event handler.\n          this._isShiftTabbing = true;\n          HTMLElement.prototype.focus.apply(this);\n          // Event handling in IE is asynchronous and the flag is removed asynchronously as well\n          setTimeout(() => {\n            this._isShiftTabbing = false;\n          }, 0);\n        }\n      });\n    }\n\n    update(props) {\n      if (props.has('disabled')) {\n        this._disabledChanged(this.disabled, props.get('disabled'));\n      }\n\n      if (props.has('tabIndex')) {\n        // save value of tabindex, as it can be overridden to\n        // undefined in case if the element is disabled\n        this[$$newTabindex] = this.tabIndex;\n        this._tabIndexChanged(this.tabIndex);\n      }\n\n      super.update(props);\n    }\n\n    updated(props) {\n      super.updated(props);\n\n      if (props.has('disabled')) {\n        this.focusElement.disabled = this.disabled;\n        if (this.disabled) {\n          this.blur();\n        }\n      }\n\n      if (props.has('tabIndex') && this[$$newTabindex] !== undefined) {\n        this.focusElement.tabIndex = this[$$newTabindex];\n        this[$$newTabindex] = undefined;\n      }\n    }\n\n    /**\n     * Any element extending this mixin is required to implement this getter.\n     * It returns the actual focusable element in the component.\n     */\n    get focusElement() {\n      window.console.warn(`Please implement the 'focusElement' property in <${this.localName}>`);\n      return this;\n    }\n\n    _focus() {\n      if (this._isShiftTabbing) {\n        return;\n      }\n\n      this.focusElement.focus();\n    }\n\n    /**\n     * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.\n     * @protected\n     */\n    focus() {\n      if (this.disabled) {\n        return;\n      }\n\n      this.focusElement.focus();\n    }\n\n    /**\n     * Native bluring in the host element does nothing because it does not have the focus.\n     * In chrome it works, but not in FF.\n     * @protected\n     */\n    blur() {\n      this.focusElement.blur();\n    }\n\n    _disabledChanged(disabled, oldDisabled) {\n      if (disabled) {\n        this[$$oldTabindex] = this.tabIndex;\n        this.tabIndex = -1;\n        this.setAttribute('aria-disabled', 'true');\n      } else if (oldDisabled) {\n        if (this[$$oldTabindex] !== undefined) {\n          this.tabIndex = this[$$oldTabindex];\n        }\n        this.removeAttribute('aria-disabled');\n      }\n    }\n\n    _tabIndexChanged(tabindex) {\n      if (this.disabled && tabindex) {\n        // If tabindex attribute was changed while checkbox was disabled\n        if (this.tabIndex !== -1) {\n          this[$$oldTabindex] = this.tabIndex;\n        }\n        this.tabIndex = null;\n      }\n    }\n  };\n","import { LitElement, html } from 'lit-element';\nimport { DelegateFocusMixin } from '../mixins/delegate-focus-mixin.js';\nimport buttonBaseStyles from '../styles/button-base-css.js';\n\nexport class ButtonElement extends DelegateFocusMixin(LitElement) {\n  static get properties() {\n    return {\n      /**\n       * Set to URL to render <a> element styled as button.\n       */\n      link: {\n        type: String,\n        reflect: true\n      }\n    };\n  }\n\n  static get styles() {\n    return buttonBaseStyles;\n  }\n\n  render() {\n    return html`\n      ${this.link\n        ? html`\n            <a class=\"button\" href=\"${this.link}\" ?disabled=\"${this.disabled}\">\n              <slot></slot>\n            </a>\n          `\n        : html`\n            <button type=\"button\" class=\"button\" ?disabled=\"${this.disabled}\" role=\"presentation\">\n              <slot></slot>\n            </button>\n          `}\n    `;\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n    this.setAttribute('role', 'button');\n  }\n\n  /**\n   * @protected\n   */\n  get focusElement() {\n    return this.shadowRoot.querySelector('.button');\n  }\n}\n","import { LitElement, html } from 'lit-element';\nimport { DelegateFocusMixin } from '../mixins/delegate-focus-mixin.js';\nimport checkboxBaseStyles from '../styles/checkbox-base-css.js';\n\nconst $$name = Symbol('name');\n\nexport class CheckboxElement extends DelegateFocusMixin(LitElement) {\n  static get properties() {\n    return {\n      /**\n       * True if the checkbox is checked.\n       */\n      checked: {\n        type: Boolean,\n        reflect: true\n      },\n\n      /**\n       * Indeterminate is a state in which it's impossible to say\n       * whether the checkbox is toggled on or off.\n       */\n      indeterminate: {\n        type: Boolean,\n        reflect: true\n      },\n\n      /**\n       * The value given to the data submitted with the name\n       * to the server when the checkbox is inside a form.\n       */\n      value: {\n        reflect: true\n      }\n    };\n  }\n\n  static get styles() {\n    return checkboxBaseStyles;\n  }\n\n  constructor() {\n    super();\n    this.checked = false;\n    this.value = 'on';\n  }\n\n  render() {\n    return html`\n      <label class=\"checkbox\">\n        <input\n          type=\"checkbox\"\n          class=\"input\"\n          ?checked=\"${this.checked}\"\n          ?disabled=\"${this.disabled}\"\n          .indeterminate=\"${this.indeterminate}\"\n          @change=\"${this._onChange}\"\n          role=\"presentation\"\n          tabindex=\"-1\"\n        />\n        <span class=\"label\"><slot></slot></span>\n      </label>\n    `;\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n\n    const name = this.getAttribute('name');\n    if (name) {\n      this.name = name;\n    }\n\n    this.setAttribute('role', 'checkbox');\n  }\n\n  update(props) {\n    super.update(props);\n\n    if (props.has('indeterminate')) {\n      this._indeterminateChanged(this.indeterminate);\n    }\n\n    if (props.has('checked')) {\n      this._checkedChanged(this.checked);\n    }\n  }\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('input');\n  }\n\n  get name() {\n    return this.checked ? this[$$name] : '';\n  }\n\n  set name(name) {\n    this[$$name] = name;\n  }\n\n  _checkedChanged(checked) {\n    if (this.indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', checked);\n    }\n    this.dispatchEvent(\n      new CustomEvent('checked-changed', {\n        detail: { value: checked }\n      })\n    );\n  }\n\n  _indeterminateChanged(indeterminate) {\n    if (indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', this.checked);\n    }\n  }\n\n  _onChange(e) {\n    const target = e.composedPath()[0];\n    this.checked = target.checked;\n    this.indeterminate = target.indeterminate;\n\n    // In the Shadow DOM, the `change` event is not leaked\n    // into the ancestor tree, so we must do this manually.\n    const changeEvent = new CustomEvent('change', {\n      detail: {\n        sourceEvent: e\n      },\n      bubbles: e.bubbles,\n      cancelable: e.cancelable\n    });\n    this.dispatchEvent(changeEvent);\n  }\n}\n","import { LitElement, html } from 'lit-element';\nimport { ifDefined } from 'lit-html/directives/if-defined';\nimport progressBaseStyles from '../styles/progress-base-css.js';\n\nexport class ProgressElement extends LitElement {\n  static get properties() {\n    return {\n      /**\n       * Current progress value. Set to null, undefined\n       * or empty string to set indeterminate state.\n       */\n      value: {\n        type: Number\n      },\n\n      /**\n       * Maximum bound to the native progress element.\n       * Note: the minimum value is always 0.\n       */\n      max: {\n        type: Number\n      }\n    };\n  }\n\n  static get styles() {\n    return progressBaseStyles;\n  }\n\n  constructor() {\n    super();\n    this.value = 0;\n    this.max = 1;\n  }\n\n  render() {\n    let { value } = this;\n    // make progress bar indeterminate\n    if (value === null || value === '') {\n      value = undefined;\n    }\n    return html`\n      <progress value=\"${ifDefined(value)}\" max=\"${this.max}\"></progress>\n    `;\n  }\n}\n","import { css } from 'lit-element';\n\nexport default css`:host{display:block}:host([hidden]){display:none !important}.range{width:100%;padding:0;margin:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none}.range::-moz-focus-outer{border:0}.range::-ms-tooltip{display:none}.range::-webkit-slider-runnable-track{width:100%}.range::-moz-range-track{width:100%}.range::-ms-track{width:100%;color:transparent}.range::-webkit-slider-thumb{border:none;-webkit-appearance:none;appearance:none}.range::-moz-range-thumb{border:none;-moz-appearance:none;appearance:none}.range::-ms-thumb{border:none;appearance:none}`;\n","import { LitElement, html } from 'lit-element';\nimport { ifDefined } from 'lit-html/directives/if-defined';\nimport { DelegateFocusMixin } from '../mixins/delegate-focus-mixin.js';\nimport rangeBaseStyles from '../styles/range-base-css.js';\n\nconst isNumeric = n => !isNaN(parseFloat(n)) && isFinite(n);\n\nexport class RangeElement extends DelegateFocusMixin(LitElement) {\n  static get properties() {\n    return {\n      value: {\n        type: Number\n      },\n\n      min: {\n        type: Number\n      },\n\n      max: {\n        type: Number\n      },\n\n      step: {\n        type: Number\n      }\n    };\n  }\n\n  static get styles() {\n    return [rangeBaseStyles];\n  }\n\n  constructor() {\n    super();\n    this.value = 0;\n    this.min = 0;\n    this.max = 100;\n    this.step = 1;\n  }\n\n  render() {\n    return html`\n      <input\n        type=\"range\"\n        class=\"range\"\n        .value=\"${this.value}\"\n        min=\"${ifDefined(this.min)}\"\n        max=\"${ifDefined(this.max)}\"\n        step=\"${ifDefined(this.step)}\"\n        ?disabled=\"${this.disabled}\"\n        aria-valuemin=\"${ifDefined(this.min)}\"\n        aria-valuemax=\"${ifDefined(this.max)}\"\n        aria-valuenow=\"${this.value}\"\n        @input=\"${this._onInput}\"\n        @change=\"${this._onChange}\"\n      />\n    `;\n  }\n\n  update(props) {\n    if (props.has('value')) {\n      if (isNumeric(this.value)) {\n        if (isNumeric(this.min) && this.value < this.min) {\n          this.value = this.min;\n        } else if (isNumeric(this.max) && this.value > this.max) {\n          this.value = this.max;\n        }\n      } else {\n        this.value = (this.max - this.min) / 2 + this.min;\n      }\n    }\n\n    if (props.has('min')) {\n      if (!isNumeric(this.min)) {\n        this.min = 0;\n      }\n    }\n\n    if (props.has('max')) {\n      if (!isNumeric(this.max)) {\n        this.max = 100;\n      }\n    }\n\n    if (props.has('step')) {\n      if (!isNumeric(this.step)) {\n        this.step = 1;\n      }\n    }\n\n    super.update(props);\n  }\n\n  updated(props) {\n    super.updated(props);\n\n    if (props.has('value')) {\n      this.dispatchEvent(\n        new CustomEvent('value-changed', {\n          detail: {\n            value: this.value\n          }\n        })\n      );\n    }\n  }\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('.range');\n  }\n\n  _onChange(e) {\n    // In the Shadow DOM, the `change` event is not leaked\n    // into the ancestor tree, so we must do this manually.\n    const changeEvent = new CustomEvent('change', {\n      detail: {\n        sourceEvent: e\n      },\n      bubbles: e.bubbles,\n      cancelable: e.cancelable\n    });\n    this.dispatchEvent(changeEvent);\n  }\n\n  _onInput(e) {\n    this.value = Number(e.target.value);\n  }\n}\n","import { LitElement, html } from 'lit-element';\nimport { DelegateFocusMixin } from '../mixins/delegate-focus-mixin.js';\nimport switchBaseStyles from '../styles/switch-base-css.js';\n\nexport class SwitchElement extends DelegateFocusMixin(LitElement) {\n  static get properties() {\n    return {\n      /**\n       * True if the checkbox is checked.\n       */\n      checked: {\n        type: Boolean,\n        reflect: true\n      }\n    };\n  }\n\n  static get styles() {\n    return [switchBaseStyles];\n  }\n\n  constructor() {\n    super();\n    this.checked = false;\n  }\n\n  render() {\n    return html`\n      <label class=\"switch\">\n        <input\n          type=\"checkbox\"\n          class=\"input\"\n          ?checked=\"${this.checked}\"\n          ?disabled=\"${this.disabled}\"\n          @change=\"${this._onChange}\"\n          role=\"presentation\"\n          tabindex=\"-1\"\n        />\n        <span class=\"label\"><slot></slot></span>\n      </label>\n    `;\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n\n    this.setAttribute('role', 'switch');\n    this.setAttribute('data-action', 'aria-switch');\n  }\n\n  update(props) {\n    super.update(props);\n\n    if (props.has('checked')) {\n      this._checkedChanged(this.checked);\n    }\n  }\n\n  get focusElement() {\n    return this.shadowRoot.querySelector('input');\n  }\n\n  _checkedChanged(checked) {\n    this.setAttribute('aria-checked', checked);\n    this.dispatchEvent(\n      new CustomEvent('checked-changed', {\n        detail: { value: checked }\n      })\n    );\n  }\n\n  _onChange(e) {\n    const target = e.composedPath()[0];\n    this.checked = target.checked;\n\n    // In the Shadow DOM, the `change` event is not leaked\n    // into the ancestor tree, so we must do this manually.\n    const changeEvent = new CustomEvent('change', {\n      detail: {\n        sourceEvent: e\n      },\n      bubbles: e.bubbles,\n      cancelable: e.cancelable\n    });\n    this.dispatchEvent(changeEvent);\n  }\n}\n"],"mappings":"AAAA;ACuBA;AAEA;;;AAIA;AACA;;;;AAOA;;;;;ACeA;AACA;AACA;AACA;;;;;;AASA;ACtBA;ACxCA;;;;AC2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA;;;;;AC3BA;AACA;AACA;;;;;;AASA","sourceRoot":""}